
<!DOCTYPE html>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

<html lang="en-us">
  <head>
    
    <script type="application/ld+json">

{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Data Structure]Tree",
  
  "image": "https://Supradax.github.io/img/tree.jpg",
  
  "datePublished": "2023-04-20T00:00:00Z",
  "dateModified": "2023-04-20T00:00:00Z",
  "author": {
    "@type": "Person",
    "name": "Supradax",
    
    "image": "https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302"
    
  },
  "mainEntityOfPage": { 
    "@type": "WebPage",
    "@id": "https:\/\/Supradax.github.io\/2023\/04\/data-structuretree\/" 
  },
  "publisher": {
    "@type": "Organization",
    "name": "Supradax's Blog",
    
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302"
    }
    
  },
  "description": "",
  "keywords": []
}

</script>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.111.3 with theme Tranquilpeak 0.5.3-BETA">
<meta name="author" content="Supradax">
<meta name="keywords" content="">
<meta name="description" content="">


<meta property="og:description" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="[Data Structure]Tree">
<meta name="twitter:title" content="[Data Structure]Tree">
<meta property="og:url" content="https://Supradax.github.io/2023/04/data-structuretree/">
<meta property="twitter:url" content="https://Supradax.github.io/2023/04/data-structuretree/">
<meta property="og:site_name" content="Supradax&#39;s Blog">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2023-04-20T00:00:00">
  
  
    <meta property="article:modified_time" content="2023-04-20T00:00:00">
  
  
  
    
      <meta property="article:section" content="Data Structure">
    
  
  
    
      <meta property="article:tag" content="Data Structure">
    
      <meta property="article:tag" content="Tree">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=640">
  <meta property="twitter:image" content="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=640">





  <meta property="og:image" content="https://Supradax.github.io/img/tree.jpg">
  <meta property="twitter:image" content="https://Supradax.github.io/img/tree.jpg">


    <title>[Data Structure]Tree</title>

    <link rel="icon" href="https://Supradax.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://Supradax.github.io/2023/04/data-structuretree/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    
    
    <link rel="stylesheet" href="https://Supradax.github.io/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://Supradax.github.io/" aria-label="Go to homepage">Supradax&#39;s Blog</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://Supradax.github.io/#about" aria-label="Open the link: /#about">
    
    
    
      
        <img class="header-picture" src="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=90" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://Supradax.github.io/#about" aria-label="Read more about the author">
          <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=110" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Supradax</h4>
        
          <h5 class="sidebar-profile-bio">An <strong>Onward</strong> Learner</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/" title="Home">
    
      <i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/categories" title="Categories">
    
      <i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/tags" title="Tags">
    
      <i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/archives" title="Archives">
    
      <i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/#about" title="About">
    
      <i class="sidebar-button-icon fas fa-lg fa-question" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/Supradax" target="_blank" rel="noopener" title="GitHub">
    
      <i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/" title="Stack Overflow">
    
      <i class="sidebar-button-icon fab fa-lg fa-stack-overflow" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Stack Overflow</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/index.xml" title="RSS">
    
      <i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaOut
               ">
        <article class="post" id="top">
          
          
            <div class="post-header main-content-wrap text-center">
  
    <h1 class="post-title">
      [Data Structure]Tree
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time datetime="2023-04-20T00:00:00Z">
        
  April 20, 2023

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://Supradax.github.io/categories/data-structure">Data Structure</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown">
            <div class="main-content-wrap">
              <h2 id="1-基本概念">1 基本概念</h2>
<h3 id="11-术语">1.1 术语</h3>
<ul>
<li>树的构成：双亲和孩子结点；左右孩子；叶子、分支和根结点；森林</li>
<li>树的类型：二叉树、满二叉树、完全二叉树、平衡二叉树、搜索二叉树、Huffman树</li>
<li>树的参数：树高(<strong>相对根节点</strong>)、深度(层数)、(结点)度数</li>
</ul>
<h3 id="12-二叉树基本性质">1.2 二叉树基本性质</h3>
<p>在二叉树中，记出度为i的结点数为$n_i(i=0,1,2)$与结点数n，且按照满二叉树排列从1开始计数. 其中$n_0$即叶子结点数</p>
<ul>
<li>$n = n_0+n_1+n_2$</li>
<li>$n_0 = n_2+1$  pf. 一条边贡献一个出度，而树满足$V=E+1$，故$n_0+n_2+n_1-1=n_1+2n_2$ □</li>
<li>高度为h的m叉树的结点最多为$\frac{m^h-1}{m-1}$ pf. 从1开始到$m^{h-1}$的等比数列求和</li>
<li>有n个结点的m叉树最小高度$\ceil{log_m(n(m-1)+1)}$  pf. 结论3的推论，反解出h即可(向上取整显然)</li>
<li>二叉树结点位置索引为k，则左右孩子索引为$2k,2k+1$；反之已知左右孩子索引$n$，则双亲为$\floor{n\over2}</li>
</ul>
<p>对于完全二叉树，则有性质：</p>
<ul>
<li>$n_1=0$ iff 奇数个结点，$n_1=1$ iff偶数个节点且<strong>只能在左子树上</strong></li>
<li>若有n个节点，则树高$\floor{log_2n}$且$i\leq \floor{n\over2}$的节点为分支，此后为叶子</li>
</ul>
<h3 id="13-概念区分">1.3 概念区分</h3>
<ol>
<li>m叉树 v.s.度数为m的树：前者指指针域内指向孩子结点的数目或孩子结点上限，可为空树；后者指最大度数结点为m，一定不能为空(至少有m+1个结点)</li>
<li>满二叉树v.s.完全二叉树：均满足$n_1=0$，但前者要求更高，必须按照从左向右依次排列，后者不需</li>
</ol>
<h3 id="15-遍历方式">1.5 遍历方式</h3>
<p>树的BFS为层序遍历(基于队列实现)，DFS为前序(pre-order)、中序(in-order)和后序遍历(post-order)，即中左右(NLR)、左中右和左右中. 以“左中右”为例，表示<strong>没有左孩子时再遍历当前结点</strong>. 在给定具体树时可以<strong>将子树按左右子树整体处理</strong></p>
<p>其中DFS非递归实现可用栈模拟递归，前序入栈则读取当前结点并将左右孩子依次压栈，直至到达叶子；中序则先入栈当前结点，不断让左孩子进栈直至到达叶子(需打标记)</p>
<h3 id="16--树二叉树与森林的转换">1.6  树、二叉树与森林的转换</h3>
<p>树的结构决定其必须选定根节点(以任意节点为根节点均能构造结构不同的一棵树)，而<strong>森林和树通过相同的方法可与二叉树等价</strong>.</p>
<ol>
<li>树与森林的变换</li>
</ol>
<ul>
<li>树→二叉树：受到存储结构<strong>孩子兄弟表示法</strong>启发，采用<strong>连线、删线</strong>的方法，即将**兄弟结点(同一个根的结点，不是同层结点)<strong>连线并接到</strong>同层最左的右孩子上(链表结构)**并删除所有双亲连接除第一个最左结点外的结点连线</li>
<li>森林→二叉树：先对森林每棵树都变为二叉树，再将每棵树的根节点依次接到前一棵树根节点的右边</li>
</ul>
<ol start="2">
<li>二叉树的逆变换(还原)</li>
</ol>
<ul>
<li>二叉树→树：只需找到每个结点左孩子的<strong>右孩子链</strong>并把双亲连上，再断开右孩子链</li>
<li>二叉树→森林：先删除所有根节点的<strong>各层最右的右孩子边</strong>实现对树的拆分(森林转换为BT后根节点右指针必为空)，再将二叉子树转换为树</li>
</ul>
<p>其中，二叉树**(先)前序遍历<strong>和变换前的森林</strong>先根遍历相同**，<strong>二叉树的中序和变换前的后根遍历相同</strong>. 先根遍历即先遍历当前结点，再遍历所有子树；后根遍历则先遍历子树再当前结点，由于非二叉，故无中根遍历(<strong>若有则表明森林退化为二叉树</strong>).</p>
<h2 id="2-存储方式">2 存储方式</h2>
<ol>
<li>
<p>双亲表示法：查双亲O(1)，查孩子O(V)，典型应用为<strong>并查集(Union Find Set)</strong></p>
</li>
<li>
<p>孩子表示法：最常用结构，即将同个结点的所有孩子链式存储(较少时如二叉树，可数组存储)；有时为回溯方便，可存储<strong>孩子的双亲索引</strong></p>
</li>
<li>
<p>孩子兄弟表示法：对每个结点，用<strong>二叉链表(指针域为n称n叉链表)</strong>，数据结构为<strong>数据域、指向第一个兄弟节点指针、指向下一个兄弟指针</strong></p>
</li>
</ol>
<p>具体实现，可基于纯链表(动态开点)、静态链表和数组(线段树)</p>
<h2 id="3-线索二叉树">3 线索二叉树</h2>
<p><strong>需求：<strong>当对二叉树频繁</strong>查找其前驱或后继以及增减结点时</strong>时，需要同步更改其<strong>中序、前序、后序和层序</strong>序列，<strong>为避免对整体递归遍历</strong>，故对二叉树<strong>线索化</strong>得到<strong>线索二叉树(Thread Binary Tree)</strong>(按四类遍历分四类线索二叉树). <strong>线索化</strong>被广泛应用在按某种顺序<strong>多次查询结点前驱后继</strong>的<strong>非线性结构</strong>中</p>
<p><strong>数据结构：</strong> 数据域、ltag和rtag(表征<strong>左右孩子是否为线索</strong>)、左右孩子. 利用**二叉树n个结点产生n+1个空指针域(这n+1个空指针全被线索化，但是不论何种线索二叉树均为剩2个空指针)**的特性，如对序列如ABCDEF，若C左孩子为空，则指向B；若右孩子为空，则指向D. 可以发现，<strong>第一个遍历到的节点左孩子为空，最后一个的右孩子为空</strong>(也可以将这两个结点设置为dummyhead的左右孩子，则遍历时无需先找到起点)</p>
<h3 id="31-中序线索二叉树">3.1 中序线索二叉树</h3>
<p>以中序遍历为例，注意其逻辑，当无左孩子时才访问中间结点，故需设置pre指向上一个访问结点和p表示当前结点，若p无左孩子，则将p的左孩子设置为pre并更新tag(表示序列前驱)，而p无右孩子的情形则不能说明问题；同理，当访问右孩子时，一定保证当前结点已经访问，从而若pre无右孩子，则pre的右孩子指向p并更新tag(表示序列后继)</p>
<p>这个过程在中序遍历的递归中即可实现，即先向左递归，在中间处理后，再向右递归.</p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>thread.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">Node* pre = NULL;
//ltag,rtag初始化为false
void setThread(Node* rt){
	if(rt)	return;
	setThread(rt-&gt;left);
	//中序处理，对前序则将下面三行移到最上方
	if(!rt-&gt;left)	rt-&gt;ltag=true,rt-&gt;left=pre;
	if(!pre-&gt;right)	pre-&gt;rtag=true,rt-&gt;right=rt;
	pre = rt;

	setThread(rt-&gt;right);
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<p>若欲利用线索，如<strong>查询结点n的后继</strong>，则rtag=1时，表明为线索，则右孩子为后继；否则根据中序，后继为右孩子的最左叶子；同理若查询前驱，ltag=1显然，否则为左孩子的最右叶子，上述即查找函数. 而有线索的二叉树，只需从<strong>最左叶子</strong>开始反复调用get_back直至空，get_back类似next中的链表，故称<strong>线索化将二叉树按照遍历顺序化为双向链表</strong>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>thread.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">Node* get_back(Node*rt){
	if(rt-&gt;rtag)	return rt-&gt;right;
	rt=rt-&gt;right;	
	while(rt-&gt;left)	rt=rt-&gt;left;
	return rt;
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</p>
<p>而若要对二叉树进行修改，则只需在插入位置附近更改线索. 以中序遍历为例，当在已有节点P后面添加节点Q时，</p>
<ol>
<li>P为叶子：Q为左孩子，则Q右指针指向P，左指针指向P原左指针域对象；Q为右孩子，Q左指针指向P，右指针指向P原右指针域对象</li>
<li>P为分支：与P为叶子完全相同</li>
</ol>
<p>上文建立的线索树为<strong>全线索树</strong>，有时只需查找前驱或后继，即左/右线索树，即<strong>只需对左/右指针域线索化</strong>.</p>
<h3 id="32-前序与后序线索二叉树">3.2 前序与后序线索二叉树</h3>
<p>对前序和后序，线索二叉树<strong>构建方式相同</strong>，只需修改递归顺序，但查询前驱后继则存在较大差异

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>thread.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">Node *pre=NULL; //初始化
void setThread(Node*rt, Node* pre){
	if(!rt) return;
	if(!pre-&gt;rs)	pre-&gt;rs=rt,pre-&gt;rtag=true;
	if(!rt-&gt;ls)	rt-&gt;ls=pre,pre-&gt;ltag=true;
	pre = rt;
}
void dfs(Node*rt){
	setThread(rt,pre); //若为中序和后序，与遍历处理方式相同
	if(rt-&gt;ls)	dfs(rt-&gt;ls);
	if(rt-&gt;rs) 	dfs(rt-&gt;rs);
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</p>
<p>后序线索二叉树的最大差异在于查询下一节点<strong>需知双亲结点</strong>，故需使用<strong>栈</strong>辅助，依旧不能有效解决问题.</p>
<ul>
<li>
<p>前序线索二叉树：第一个元素即根节点，然后反复调用nxtNode()函数. 其中nxtNode当tag非零时对应指向对象为所求，否则后继为右子树最左叶子，前驱为左子树最右叶子.</p>
</li>
<li>
<p>后序线索二叉树：第一个元素即最左叶子，同理反复调用nxtNode()，当tag非零时指向r即所求，否则分三类：</p>
</li>
</ul>
<ol>
<li>若r是rt，则后继为空</li>
<li>若r是ls且p有rs，则r后继为rs的最左叶子</li>
<li>若r是rs 或 r是ls但p无rs，则r后继为p</li>
</ol>
<h2 id="4-morris遍历">4 Morris遍历</h2>
<p>定义<strong>Morris(遍历)序</strong>，整个遍历策略为：</p>
<ul>
<li>cur无左树，则cur向右移动(通过右指针)</li>
<li>cur有左树，则移动到<strong>左树的最右端mostRight</strong>，若mostRight的<strong>右指针为空，则指到cur</strong>，<strong>若非空，则置空</strong>. 然后cur左移动.</li>
</ul>
<p>对形如下图的树，Morris序为1242513637. 观察有<strong>节点无左树，出现一次；节点有左树，则出现两次且在两次之间一定能把左树遍历完</strong></p>
<p><strong>核心</strong> 利用<strong>叶子的空闲指针</strong>往上指回去.

 
 
 <div class="figure center" >
   
     <img class="fig-img" src="https://Supradax.github.io/img/treedp/20.jpg" >
   
   
 </div>
</p>
<p>通过Morris序，可以转换为先中后序遍历，判断BST.</p>
<ul>
<li><strong>先序</strong>. 第一次来到即访问.</li>
<li><strong>中序</strong>. 只能到一次，直接访问；能回到两次则第二次再打印（若有左树，说明能回2次，先不访问；若叶子结点有右指针，说明这次是第二次）.</li>
<li><strong>后序</strong>. 第二次到达时，<strong>逆序打印左子树的右边界</strong></li>
</ul>
<p><strong>复杂度</strong>. 不用额外栈空间，故空间复杂度为O(1). 下面证明<strong>不断向右找最右叶子的过程不会导致总时间复杂度超过O(n)</strong> 考虑一个完全满二叉树，则每次都会看左树的右边界2次，<strong>相当于每个子树的左子树的最右链剖分</strong>，故仍然线性.</p>
<p><strong>Notes.</strong> Morris（<strong>第二次回到之前可解决</strong>）. 递归讨论（必须<strong>第三次</strong>回到结点，如树形dp左右子树信息整合）. 凡是与遍历有关的，可<strong>以Morris作最优解</strong>，如中序检查BST.</p>
<h2 id="5-huffman树">5 Huffman树</h2>
<p><strong>据频率分布分配不同字符(串)不等长编码</strong>从而节省内存，但不等长导致有时操作困难. 具体字符(串)只在叶子且从rt出发到达叶子的路径，按层序依次编号，如$010$(0/1表示向左/右的边). 具体算法为将各叶子按频率进行排序，选取最小的两个合并(频率相加)，不断选取两个最小的合并直至只剩一个作为根节点，故<strong>Huffman树不唯一</strong></p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>huffman.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">class Node{
public:
	char info = 0;
	float freq = 0;
	Node* ls, *rs; 
	
	bool operator &lt;(Node &amp;a, Node&amp;b){
		return a.freq&lt;b.freq;
	}
}

vector&lt;Node&gt; chars;
Node* huffman(){
	priority_queue&lt;Node*&gt; q;
	for(auto ele:chars)	q.push(ele); //排序初始化

	while(q.size()!=1){
		Node* a = q.top(); q.pop();
		Node* b = q.top(); q.pop();
		Node* c = (Node*)malloc(sizeof(Node));
		c.ls = a, c.rs=b;
		q.push(c);
	}
	return q.top();
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<h2 id="6-堆">6 堆</h2>
<h3 id="61-二叉堆">6.1 二叉堆</h3>
<p>堆分为<strong>小顶堆(minheap)和大顶堆(maxheap)</strong>，以小顶堆为例，堆是一个<strong>满足任意子树的根节点小于子树任意节点的完全二叉树</strong>. 堆支持<strong>上滤</strong>和<strong>下滤</strong>的操作.</p>
<p>将所有元素放入堆中并依次取出堆顶元素，则实现<strong>堆排序</strong>，该数据结构加以封装即为<strong>优先队列</strong></p>
<ul>
<li><strong>上滤(sift up)和下滤(sift down)</strong>
由于堆是完全二叉树这类稠密树，故采用<strong>顺序存储</strong>. 上滤，将一个元素放至数组末尾，并维护其比父节点大的性质(不满足则不断交换直至满足或到达堆顶)；下滤则将元素放至堆顶，与<strong>两个孩子中较小者比较，若比其大则交换，直至成为叶子或满足</strong></li>
</ul>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>sift.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">void sift_up(int cnt){
	while(cnt&amp;&amp;t[cnt]&lt;t[cnt/2])
		swap(t[cnt],t[cnt/2]), cnt/=2;
}
void sift_down(int cnt){
	while(t[cnt]){ //保证非空
		int idx = t[cnt*2&#43;1]&lt;t[cnt*2&#43;2]? cnt*2&#43;1:cnt*2&#43;2;
		if(t[idx]&lt;t[cnt])
			swap(t[idx],t[cnt]), cnt=idx;
	}
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<ul>
<li>建堆
建堆分<strong>自顶而下</strong>和<strong>自下而上</strong>. 自顶向下，即将所有元素放至元素末尾，执行上滤. 平均对每个元素上滤复杂度为O(logn)，故整体<strong>O(nlogn)</strong>. 自下而上，则将堆乱序建好，再从倒数第二层开始依次往上执行上滤. 则对第h层有$2^{h-1}$个元素，平均复杂度为\sum_{(h-1)2^{h-1}}$，而$n=\sum_{h2^h}$，可知复杂度为O(n).</li>
</ul>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>creation.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">void build_downwards(int data[],int size){
	for(int cnt=0;cnt&lt;size;cnt&#43;&#43;){
		t[cnt]-&gt;val=data[cnt];
		sift_up(cnt);
	}
}

void build_from_ground_up(int data[],int size){
	for(int cnt=0;cnt&lt;size;cnt&#43;&#43;)
		t[cnt]-&gt;val = data[cnt];
	//为编程方便，从倒数第一层开始也可
	while(cnt)	sift_up(cnt--);
	
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<ul>
<li>增减元素
对增添元素，只需放在末尾(与自顶向下相同)再上滤，复杂度O(logn)；对删减堆顶元素，则<strong>将末尾元素替换掉堆顶元素再下滤</strong>，复杂度O(logn).</li>
</ul>
<h3 id="62-可并堆左偏树">6.2 可并堆：左偏树</h3>
<p>优先队列过度封装，有时需合并两个堆，则无法完成. 一般可并堆有Fibonacci堆、左偏树与配对堆. 后二者代码量小，较常见.</p>
<p><strong>左偏树</strong>(小顶堆为例)，满足结点不大于儿子的键值. <strong>距离</strong>为到达<strong>最近的外结点</strong>（无左或右儿子）的距离. 左偏树维护<strong>左子节点的距离不小于右子节点的距离，即左侧更密</strong>，从而一个结点的距离被定义为小的一个，即<strong>右子节点的距离+1</strong>. <strong>空结点距离定义为-1(叶子为0)</strong>.</p>
<p>在合并过程中进行递归合并，若左子节点距离小于右子节点，则交换之；并且维护当前结点距离，即为递归后的右结点距离+1.</p>
<p><strong>例题</strong> 维护n个小根堆，每个堆有且仅有一个数，支持两种操作：将第x、y个数所在堆合并；输出第x个数所在堆的最小数并删之.</p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>Leftlist Tree.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">#define ls(x) llt[x].l
#define rs(x) llt[x].r
typedef struct Node{int l,r,fa,val,dis;} llt[N];
int merge(int x,int y){
	if(!x||!y)	return x&#43;y; //有个空则返回其中一个
	//让大的往小的树上合并
	if(llt[x].val&gt;llt[y].val||(llt[x].val==llt[y].val &amp;&amp; x&gt;y))	
		swap(x,y);
	rs(x)=merge(rs(x),y);
	llt[rs(x)].fa=x;	//维护父节点
	if(llt[ls(x)].dis&lt;llt[rs(x)].dis)	swap(ls(x),rs(x)); 
	llt[x].dis = llt[rs(x)].dis&#43;1; //维护距离
	return x;
}
void pop(int x){
	llt[x].val=-1; //打个标记表示删除
	//独立成堆，再次合并
	llt[ls(x)]=ls(x), llt[rs(x)]=rs(x);
	//必须有赋值，否则有些会断掉，x不起作用只是挂着
	llt[x].fa=merge(ls(x),rs(x)); 
}
//可使用路径压缩，破坏的是并查集结构不是左偏树的结构
int find(int x){return llt[x].fa==x?x:llt[x].fa=find(llt[x].fa);}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<h2 id="7-bst">7 BST</h2>
<p>二分搜索树(Binary Search Tree)，比堆的性质更好，满足<strong>根节点≥左子树任意节点且≤右子树任意节点</strong>. 故而可进行二分查找.</p>
<h3 id="71-二分查找">7.1 二分查找</h3>
<p><strong>二分查找(折半查找)</strong>，即对<strong>有序数组</strong>进行划分. 为了解决边界问题，<strong>令l=-1，r=N，留出边界(否则当目标在左右边界上时需特判)</strong>，如此则退出条件为<strong>l和r相邻</strong>，则<strong>l为小于的上确界，r为大于的下确界</strong></p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>binary search</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">int find(vector&lt;int&gt; data, int target){
	int l=-1, r=data.size();	//假定data单调递增
	while(l&#43;1!=r){
		int m = l&#43;r&gt;&gt;1;
		if(data[m]==target) return m;
		if(data[m]&gt;target)	r=m;
		else l=m;
	}
	return EOF;
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<p>利用该程序，第一个大于target的元素索引为r，最后一个≤target的元素为l.</p>
<p>实际上除去区间查找问题，对于满足<strong>若有m个能解决问题，则比m多或少的时候也能解决问题</strong>这类<strong>存在包含序关系</strong>的条件，则可对m进行二分降低复杂度.</p>
<ul>
<li><strong>例1</strong>对给定的一些长方形巧克力，要求将其<strong>垂直或水平</strong>切开分给k个人<strong>等大正方形</strong>巧克力，试求满足的最大的正方形边长.</li>
</ul>
<p>  <strong>Sol.</strong> 显然若边长为m时为最优解，则任何比m小的都是解，故可二分. 下界为0，上界为所有长方形最长的一边的最大值.若a/m*b/m之和大于n，则向上二分，反之向下</p>
<ul>
<li><strong>例2</strong> 扫地机器人. 一列方格，已知机器人布局，若要求机器人一段时间后返回出发点，每次可以移动至相邻方格取清扫，求能清扫所有区域的最快结束时间.</li>
</ul>
<p>  <strong>Sol.</strong> 对时间二分，一定不超2N，再看第一个机器人，由贪心可知一定得往左回去再回到原位，若还有剩余时间，尽可能向右扫；再看第二个，由贪心知至少得和第一个到达的最远距离接上，接不上则向上二分；全接上则向下.</p>
<p><strong>Notes. 查找的基础知识</strong>
常见的查找算法有<strong>顺序、二分、分块、哈希等</strong></p>
<ol>
<li>定义$ASL=p_iX_i$(Average Search Length)为查询一个元素平均所需的次数(<strong>只有访问到有数据的结点才计数</strong>)，其中$X$为各个数据项的随机变量，$p_i$为对应的分布列. ASL分为查找成功和失败两类，除通过分布列计算，还可用基本事件数计算，如含n个元素的顺序查找$ASL_{succ}=\frac{1}{n}(\sum in_i)=\frac{n+1}{2}, ASL_{fail}=\frac{1}{n}n^2=n$（查找失败都需查到顺序表末）</li>
<li>对顺序查找，通过设置前后**哨兵(Sentry)**能简便处理越界</li>
<li>对二分查找，要求<strong>支持随机访问且数据有序</strong>平均一定快于顺序，但对某个数据项不一定总快于(如表头或表末)，其空指针域代表查找失败数据项(但不占用一次查找次数，因为空指针上无数据项). 由二分查找构建的<strong>二分查找树</strong>一定满足<strong>任意节点左子树结点数等于或比右子树多1</strong></li>
<li><strong>分块查找</strong>，是<strong>综合顺序和二分查找</strong>的产物，由<strong>索引表(有序)和块(可无序)</strong>，其中<strong>索引值为对应块的最值</strong>，以最大值为例，<strong>满足后续所有块中数据的值均不小于该值</strong>. 若将主表均分k段，则$ASL=\frac{k(k+1)}{2}+\frac{\frac{n}{k}(\frac{n}{k}+1)}{2}$，解得当$k=\sqrt{n}$时效率最高. 其中若将<strong>索引表查询二分优化</strong>，则优化为$ASL=log_2{k}+\frac{\frac{n}{k}(\frac{n}{k}+1)}{2}$(准确地讲log是<strong>渐进近似</strong>)



<div class="figure center" >
  
    <img class="fig-img" src="https://Supradax.github.io/img/linearlist/10.jpg" >
  
  
</div>
</li>
<li>二分查找、BST的序列满足<strong>不交叉(类似聚点定理的二分证明)</strong></li>
</ol>
<h3 id="72-三分查找">7.2 三分查找</h3>
<h3 id="73-bst">7.3 BST</h3>
<p>二叉查找/搜索树(Binary Search Tree)，相比堆，满足<strong>左子树所有数据的值不大于当前结点，右子树则不小于</strong>，故有<strong>中序遍历为单调递增序列</strong></p>
<ul>
<li>查询、插入与删除
查询为二分操作，插入删除均基于查询. 插入只需查询该节点是否存在(假设相同权值的只存储一个)，查至叶子仍不存在则添加；删除同理查询，若为叶则直接删除，若只有一个孩子则缩点，若有两个则<strong>找到直接后继或直接前驱放在原来的位置</strong>，由中序遍历可知，该结点可以是<strong>左子树的最右结点或右子树的最左结点</strong></li>
<li>建树
BST的建树可自顶向下采用插入操作，复杂度O(nlogn).</li>
</ul>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>bst.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">Node* query(Node*rt, int val){
	if(!rt)	return nullptr;
	else if(rt-&gt;val == val)	return rt;
	
	return rt-&gt;val&gt;val? query(rt-&gt;ls,val):query(rt-&gt;rs,val);
}

void insert(int val){
	if(!rt||rt-&gt;val == val)	return;
	if(!rt-&gt;ls &amp;&amp; !rt-&gt;rs)	
		if(rt-&gt;val&lt;val)	rt-&gt;rs = new Node(val);
		else rt-&gt;ls = new Node(val);
}

bool del(int val){
	Node* target = query(rt,val);
	if(!target)	return false;
	if(!target-&gt;ls&amp;&amp;!target-&gt;rs)	//叶子结点
		target = nullptr;
	else if(target-&gt;ls)	//一个孩子
		target = target-&gt;ls;
	else if(target-&gt;rs)
		target = target-&gt;rs;
	else{	//两个孩子
		Node* p =target-&gt;rs;
		while(p-&gt;ls)	p=p-&gt;ls;
		p-&gt;rs = target-&gt;rs;
		target = p;
	}
	return true;
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<h3 id="74-avl">7.4 AVL</h3>
<p>AVL，<strong>自平衡二叉树</strong>. 如当BST不断执行插入有序数列时，<strong>BST会退化为单链表</strong> ，AVL则在BST基础上涉及一套平衡机制避免该退化情况.</p>
<p>在AVL中，每个结点相比BST具有<strong>平衡因子(Balance Factor)</strong>，定义为<strong>左子树平衡因子-右子树平衡因子</strong>，且叶子bf=0(初始化). 当插入节点时，需进行回溯将路径上所有结点的平衡因子进行更新</p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>avl.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">//判断二叉树是否平衡
bool isBalanced(Node* rt){
	if(!rt &amp;&amp; !rt-&gt;ls &amp;&amp; !rt-&gt;rs) return true; //叶子和空节点总是平衡的
	if(abs(rt-&gt;ls-&gt;bf-rt-&gt;rs-&gt;bf)&gt;1)	return false;
	return isBalanced(rt-&gt;ls)&amp;&amp;isBalanced(rt-&gt;rs); //只要一侧不平衡则整棵不平衡
}
//插入节点并更新bf值，假定该节点一定不存在
int insert(Node* rt, int val){
	if(rt){
		rt=new Node(val,0);	//到达目标结点
		return 1;
	}
	//递归查找并获取树高
	if(val&gt;rt-&gt;val)	rt-&gt;h=rt-&gt;ls? rt-&gt;ls-&gt;h-insert(rt-&gt;rs, val):-insert(rt-&gt;rs, val);
	else rt-&gt;h=rt-&gt;rs?:insert(rt-&gt;ls,val)-rt-&gt;rs-&gt;h:insert(rt-&gt;ls);
	//回溯，返回最大树高
	int h = 0;
	if(rt-&gt;ls)	h&#43;=rt-&gt;ls-&gt;h;
	if(rt-&gt;rs)  h&#43;=rt-&gt;rs-&gt;h;
	return h;
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<p>可见，当插入节点时，可能导致BF绝对值超过1，此时需通过<strong>左旋或右旋</strong>来维护AVL性质(使用旋转目的在于不改变BST的有序性). 一般根据插入节点位置不同分为<strong>LL、LR、RL、RR</strong>四类，对应方法分别为<strong>右旋、右旋+左旋、左旋+右旋、左旋.</strong></p>
<p>下面设插入到子节点C的插入结点为P，祖父、父和子结点为A,B,C. 则：</p>
<ul>
<li>LL: P插入到C的左侧，B、C左重右轻，BF分别为2和1，则在插入该子节点后，将B和C右旋(逆时针旋转)使得C的父节点由B变A，B的父节点由A变C.</li>
<li>RR:</li>
<li>LR:</li>
<li>RL:

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>avl.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">void rotate_rightwards(Node* a){	//赋值三次指针
	Node *b=a-&gt;ls, *c = a-&gt;ls-&gt;ls;	
	a-&gt;ls=c, b-&gt;ls=c-&gt;ls, c-&gt;ls=b; 
}
void rotate_leftwards(){
	Node *b=a-&gt;rs, *c = a-&gt;rs-&gt;rs;	
	a-&gt;rs=c, b-&gt;rs=c-&gt;ls, c-&gt;rs=b; 
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</li>
</ul>
<h3 id="8-st表与lca">8. ST表与LCA</h3>
<h4 id="81-st表倍增算法">8.1 ST表：倍增算法</h4>
<p>解决区间最值问题(RMQ)一般用<strong>ST表(Sparse Table)</strong>（不支持修改）和<strong>线段树</strong>，建表均为O(nlogn)，查询分别为O(1),O(logn).</p>
<p>由于任何数都能唯一表示为一个二进制数，故从区间左端点向右和右端点向左，一定存在m,n使得$[a,a+2^m-1],[b-2^n+1,b]$覆盖$[a,b]$，从而只需求$\max f(a,m),f(b-2^n+1,n)$. 从而引出定义f(a,m)为$[a,a+2^m-1]$上的区间最值.</p>
<p>初始化使用类似归并的DP. [i,j]拆分成$[i,i+2^{j-1}-1],[i+2^{j-1},j-1]$. 查询则找到对应的$k=\log_2{r-l+1}$使其能覆盖

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>st.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">void init(){
	//从[i,i]的最值为自身
	for(int i=1;i&lt;=n;i&#43;&#43;)	f[i][0]=a[i];
	int k = log2(n); //防止越界
	for(int j=1;j&lt;=k;j&#43;&#43;)
		for(int i=1;i&lt;=n-(1&lt;&lt;j)&#43;1;i&#43;&#43;)
			f[i][j] = max(f[i][j-1],f[i&#43;(1&lt;&lt;(j-1))][j-1]);
}
int query(int l,int r){
	int k = log2(r-l&#43;1);
	return max(f[l][k],f[r-(1&lt;&lt;k)&#43;1][k]);
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</p>
<p>借鉴倍增算法，对查询LCA（静态），先构建ST表，定义**$f(i,j)$：i为起点，向上跳$2^j$层的结点**. 故先做dfs构建st表，同理递推构建. 然后再用ST求LCA.
1.先让u,v跳到<strong>相同高度</strong>. 由于两点深度差可作二进制拆分，其中<strong>含1的个数为跳跃次数</strong>，一定能跳到同一层.
2. 位于同一层，故<strong>同步向上</strong>即可

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>st.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">int dep[N], f[N][20]; //20表示深度最大2^20
void dfs(int u, int fa){
	dep[u]=dep[fa]&#43;1;
	//倍增拆分：跳2^i等于跳2次2^i-1
	for(int i=1;i&lt;=19;i&#43;&#43;)
		f[u][i]=f[f[u][i-1]][i-1];
	
	for(int v:e[u])	
		if(v!=fa)	dfs(v,u);
}

int lca(int u, int v){
	if(dep[u]&lt;dep[v])	swap(u,v);
	for(int i=19;i&gt;=0;i--)	//反向遍历
		if(dep[f[u][i]]&gt;=dep[v])	u=f[u][i];
	if(u==v)	return v; //恰好共线
	for(int i=19;i&gt;=0;i--)
		if(f[u][i]!=f[v][i])	u=f[u][i],v=f[v][i];
	return f[u][0];
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</p>
<h4 id="82-tarjan方案">8.2 Tarjan方案</h4>
<p>Tarjan用<strong>并查集离线</strong>解决LCA. 其核心思想为<strong>一次性输入完成查询</strong>. 首先遍历打vis标记，往没打的走，然后反向建边（fa[]数组），离开u时处理掉所有以u为起点的询问，若另一个v已访问，则其必然在最近的一个子树. 从而有：

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>tarjan</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">int fa[N],vis[N],ans[M];
int find(int u){return fa[u]==u? u: fa[u]=find(fa[u]);}

void tarjan(int u){
	vis[u]=true;
	for(auto v:neighbor[u])
		if(!vis[v]){tarjan(v);fa[v]=u;}
	for(auto q:query[u]{ //q:&lt;visit,number&gt;
		if(vis[q.first])	
			ans[q.second]=find(q.first);	
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</p>
<h4 id="83-树链剖分">8.3 树链剖分</h4>
<p>先用第一次做轻重儿子标记，完成son[],depth[],size[],father[]的统计,第二次完成<strong>链头top[]<strong>的统计，其中</strong>先搜重儿子，这与树上启发式合并相反</strong>. 然后调用lca.</p>
<p><strong>Note</strong> 也可不用轻重链剖分，只要是形成单链的树链剖分均可.

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>lca</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">void dfs2(int u,int t){
	top[u] = t; //链头
	if(!son[u])	return; //无重儿子返回
	dfs(son[u],t); //传导链头，让同个重链的重儿子指向同个
	for(int v:neighbor[u]){
		if(v==fa[u]||v==son[u])	continue;
		dfs2(v,v); //轻儿子以自己为链头
	}
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		//u在v下方，使低的一方上升直至二者位于同一条链
		if(dep[top[u]]&lt;dep[top[v]])	swap(u,v);
		u = fa[top[u]]; 
	}
	return dep[u]&lt;dep[v]? u:v;
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</p>
<p>三种方法中倍增为O((n+m)logn)、Tarjan为O(n+m)、树链剖分为O(n+mlogn). 总结为倍增深搜打表、跳跃查询；Tarjan为入回离（深搜建反边、最近子树做路径压缩）；树链剖分两次深搜打表，按链头跳跃至同链再查询.</p>
              


            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://Supradax.github.io/tags/data-structure/">Data Structure</a>

  <a class="tag tag--primary tag--small" href="https://Supradax.github.io/tags/tree/">Tree</a>

                  </div>
                
              
            
            
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://Supradax.github.io/2023/04/modeling-ibasic-prediction-and-optimization-models/" data-tooltip="[Modeling I]Basic Prediction and Optimization Models" aria-label="NEXT: [Modeling I]Basic Prediction and Optimization Models">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://Supradax.github.io/2023/04/calculusintegral-inequalities-ep.2/" data-tooltip="[Calculus]Integral: Inequalities ep.2" aria-label="PREVIOUS: [Calculus]Integral: Inequalities ep.2">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://Supradax.github.io/2023/04/data-structuretree/" title="Share on Facebook" aria-label="Share on Facebook">
          <i class="fab fa-facebook-square" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://Supradax.github.io/2023/04/data-structuretree/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/sharing/share-offsite/?url=https://Supradax.github.io/2023/04/data-structuretree/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
    <li class="post-action">
      <a class="post-action-btn btn btn--default" href="#disqus_thread" aria-label="Leave a comment">
        <i class="far fa-comment"></i>
      </a>
    </li>
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


            
  
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'https:\/\/Supradax.github.io\/2023\/04\/data-structuretree\/';
        
          this.page.identifier = '\/2023\/04\/data-structuretree\/'
        
      };
      (function() {
        
        
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
          document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
          return;
        }
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'hugo-tranquilpeak-theme';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
  


          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2023 Supradax. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://Supradax.github.io/2023/04/modeling-ibasic-prediction-and-optimization-models/" data-tooltip="[Modeling I]Basic Prediction and Optimization Models" aria-label="NEXT: [Modeling I]Basic Prediction and Optimization Models">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://Supradax.github.io/2023/04/calculusintegral-inequalities-ep.2/" data-tooltip="[Calculus]Integral: Inequalities ep.2" aria-label="PREVIOUS: [Calculus]Integral: Inequalities ep.2">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://Supradax.github.io/2023/04/data-structuretree/" title="Share on Facebook" aria-label="Share on Facebook">
          <i class="fab fa-facebook-square" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://Supradax.github.io/2023/04/data-structuretree/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/sharing/share-offsite/?url=https://Supradax.github.io/2023/04/data-structuretree/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
    <li class="post-action">
      <a class="post-action-btn btn btn--default" href="#disqus_thread" aria-label="Leave a comment">
        <i class="far fa-comment"></i>
      </a>
    </li>
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


      </div>
      
<div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-times"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2FSupradax.github.io%2F2023%2F04%2Fdata-structuretree%2F" aria-label="Share on Facebook">
          <i class="fab fa-facebook-square" aria-hidden="true"></i><span>Share on Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2FSupradax.github.io%2F2023%2F04%2Fdata-structuretree%2F" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2FSupradax.github.io%2F2023%2F04%2Fdata-structuretree%2F" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i><span>Share on Linkedin</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>


    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-times"></i>
    </div>
    
      <img id="about-card-picture" src="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=110" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Supradax</h4>
    
      <div id="about-card-bio">An <strong>Onward</strong> Learner</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        <strong>HITsz</strong>er
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker-alt"></i>
        <br/>
        Shenzhen,China
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://Supradax.github.io/img/cover.png');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js" integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script src="https://Supradax.github.io/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js"></script>


  
    <script async crossorigin="anonymous" defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js"></script>
  


<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>




    
  </body>
</html>

