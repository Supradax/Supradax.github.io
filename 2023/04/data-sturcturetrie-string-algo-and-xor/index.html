
<!DOCTYPE html>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

<html lang="en-us">
  <head>
    
    <script type="application/ld+json">

{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Data Sturcture]Trie, String Algo and XOR",
  
  "image": "https://Supradax.github.io/img/trie.jpg",
  
  "datePublished": "2023-04-04T00:00:00Z",
  "dateModified": "2023-04-04T00:00:00Z",
  "author": {
    "@type": "Person",
    "name": "Supradax",
    
    "image": "https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302"
    
  },
  "mainEntityOfPage": { 
    "@type": "WebPage",
    "@id": "https:\/\/Supradax.github.io\/2023\/04\/data-sturcturetrie-string-algo-and-xor\/" 
  },
  "publisher": {
    "@type": "Organization",
    "name": "Supradax's Blog",
    
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302"
    }
    
  },
  "description": "Trie, 字典树，用于快速查询有限组合的序列。\n",
  "keywords": []
}

</script>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.111.3 with theme Tranquilpeak 0.5.3-BETA">
<meta name="author" content="Supradax">
<meta name="keywords" content="">
<meta name="description" content="Trie, 字典树，用于快速查询有限组合的序列。">


<meta property="og:description" content="Trie, 字典树，用于快速查询有限组合的序列。">
<meta property="og:type" content="article">
<meta property="og:title" content="[Data Sturcture]Trie, String Algo and XOR">
<meta name="twitter:title" content="[Data Sturcture]Trie, String Algo and XOR">
<meta property="og:url" content="https://Supradax.github.io/2023/04/data-sturcturetrie-string-algo-and-xor/">
<meta property="twitter:url" content="https://Supradax.github.io/2023/04/data-sturcturetrie-string-algo-and-xor/">
<meta property="og:site_name" content="Supradax&#39;s Blog">
<meta property="og:description" content="Trie, 字典树，用于快速查询有限组合的序列。">
<meta name="twitter:description" content="Trie, 字典树，用于快速查询有限组合的序列。">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2023-04-04T00:00:00">
  
  
    <meta property="article:modified_time" content="2023-04-04T00:00:00">
  
  
  
    
      <meta property="article:section" content="Data Structure">
    
  
  
    
      <meta property="article:tag" content="Algorithm">
    
      <meta property="article:tag" content="Graph">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=640">
  <meta property="twitter:image" content="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=640">





  <meta property="og:image" content="https://Supradax.github.io/img/trie.jpg">
  <meta property="twitter:image" content="https://Supradax.github.io/img/trie.jpg">


    <title>[Data Sturcture]Trie, String Algo and XOR</title>

    <link rel="icon" href="https://Supradax.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://Supradax.github.io/2023/04/data-sturcturetrie-string-algo-and-xor/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    
    
    <link rel="stylesheet" href="https://Supradax.github.io/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://Supradax.github.io/" aria-label="Go to homepage">Supradax&#39;s Blog</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://Supradax.github.io/#about" aria-label="Open the link: /#about">
    
    
    
      
        <img class="header-picture" src="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=90" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://Supradax.github.io/#about" aria-label="Read more about the author">
          <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=110" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Supradax</h4>
        
          <h5 class="sidebar-profile-bio">An <strong>Onward</strong> Learner</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/" title="Home">
    
      <i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/categories" title="Categories">
    
      <i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/tags" title="Tags">
    
      <i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/archives" title="Archives">
    
      <i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/#about" title="About">
    
      <i class="sidebar-button-icon fas fa-lg fa-question" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/Supradax" target="_blank" rel="noopener" title="GitHub">
    
      <i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/" title="Stack Overflow">
    
      <i class="sidebar-button-icon fab fa-lg fa-stack-overflow" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Stack Overflow</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://Supradax.github.io/index.xml" title="RSS">
    
      <i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaOut
               ">
        <article class="post" id="top">
          
          
            <div class="post-header main-content-wrap text-center">
  
    <h1 class="post-title">
      [Data Sturcture]Trie, String Algo and XOR
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time datetime="2023-04-04T00:00:00Z">
        
  April 4, 2023

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://Supradax.github.io/categories/data-structure">Data Structure</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown">
            <div class="main-content-wrap">
              <p><strong>Trie</strong>, 字典树，用于快速查询有限组合的序列。</p>
<p>业务需求：加入一个序列；查询某个序列是否在树中；删除一个序列
以典型的含26个字母的字典树为例，定义哈希值0-25对应a-z，则在二叉树的基础上，需一个26叉树结构（静态树）与标记<code>cnt[]</code>(定义为以该节点结束的字符串的个数)并给其中一些已使用的节点进行标号，便于直接查找</p>
<h2 id="1-template">1 Template</h2>
<p>
  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>Trie</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">int ch[N][26]={0},cnt[N]={0}, idx=0;
//插入操作
void insert(string s){
	int cur = 0;
	for(int i=0;i&lt;s.length();i&#43;&#43;){
		int j = s[i]-&#39;a&#39;;
		if(!ch[cur][j])	ch[cur][j]=&#43;&#43;idx;	//开点
		cur = ch[cur][j];
	}
	cnt[cur]&#43;&#43;;
}
//查询操作：若存在则返回idx，否则为0
int query(string s){
int cur = 0;
	for(int i=0;i&lt;s.length();i&#43;&#43;){
		int j = s[i]-&#39;a&#39;;
		if(!ch[cur][j])	return 0;
		cur = ch[cur][j];
	}
	return cnt[cur];
}
//删除操作
void del(string s){
	int p = query(s);
	if(!p)	cnt[p]--;
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

**时间复杂度：**建树与查询均为O(n)</p>
<h2 id="2-0-1-trie">2. 0-1 Trie</h2>
<h4 id="sample-problem-最大异或对">Sample Problem 最大异或对:</h4>
<p><strong>Problem</strong> 给定n个整数，任选两个进行异或，求得到的最大异或对.
<strong>Analysis</strong> 异或运算，联想到二进制序列，对于二进制每次均只需保证最高位能取到1，依次向下即可. （每一次选择的集合都包含最优解）从而只需维护一个0,1的二叉字典树并用贪心，当1存在时走1，否则走0. 整体复杂度为O(31n). 由于分叉数m不多，从而也可遍历一遍整个单链结构，复杂度O(2n).</p>
<ul>
<li>0-1字典树实现：

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>0-1Trie</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">int ch[N*31][2], idx;
void insert(int x){
	int p=0;
	for(int i=30;~i;i--){
		int j = x&gt;&gt;i&amp;1;	//取出第i位
		if(!ch[p][j])	ch[p][j]=&#43;&#43;idx;
		p=ch[p][j];
	}
}
int query(int x){	//需对每个数都检查一遍
	int p=0, res=0;
	for(int i=30;~i;i--){
		int j = x&gt;&gt;i&amp;1;	//取出第i位
		if(ch[p][!j]) {
			res &#43;= 1&lt;&lt;i;
			p = ch[p][!j];
		}else
			p=ch[p][j];
	}
	return res; 
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</li>
<li>集合实现：状态压缩

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>0-1Trie</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">int ch[32][2]={0};
void insert(int n){
	int cur = 0;
	for(int i=0; i&lt;=30;i&#43;&#43;){
		int j = (1&lt;&lt;i)&amp;n;
		if(j&gt;0)	ch[i][1]=1;
		else ch[i][0]=1;
	}
}
/*main*/
for(int i=30;~i;i--)
		if(ch[i][0] &amp;&amp; ch[i][1])	res|=(1&lt;&lt;i);</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</li>
</ul>
<h2 id="3-kmp算法单模态匹配">3. KMP算法：单模态匹配</h2>
<p><strong>模式匹配(Pattern Matching)</strong>，即在给定的字符串<code>s</code>中寻找是否与指定字符串<code>t</code>相同的子串. 子串可推广到任意序列. 逐一比较虽然可行，但当所需子串长度足够长时，时间复杂度达到O(mn)，其中m为<code>t</code>的长度，n为<code>s</code>的长度.</p>
<p>该问题的难点在于如何处理<strong>匹配到一半发现不符合</strong>的尴尬情况，在上述做法中即换下一个字母，从头遍历一遍<code>t</code>，<code>s</code>也要从最前面的下一个字母遍历，我们的改进点在于：<strong>能不能不从头开始？</strong></p>
<p>我们先看是否存在这样的特殊情况能够不重新开始. 设指针<code>i,j</code>指向<code>s,t</code>，形如在<code>aaacaaab</code>中匹配<code>aaab</code>，当遍历到<code>c</code>时发现不同，如果让<code>i</code>回退到第二个a处，显然是没必要的；又如更典型的例子<code>aaaaaab</code>中匹配<code>aaab</code>，可以发现<strong>无需回退i，只要回退j</strong>也能达到目的. 假定此时i指向第四个a，j指向b，发现不同，从而j回退到第三位而i前进直至找到<code>b</code>.</p>
<p>在这个过程中，我们知道当i,j不匹配时，j要回退；但j回退到哪，是核心问题. 该问题可用DP解决且易知这个数组<strong>只和模式串<code>t</code>有关，与<code>s</code>无关</strong>.</p>
<p>考察这样一个字符串，如果<code>xxxxxy...xxxxx</code>前5个字母和后5个字母完全等同且&rsquo;s&rsquo;字母是&rsquo;y&rsquo;，则可将其从末尾跳转到第6个重新匹配（由于前后缀一样，我们至少保证了前6个字母一定一致；相反，若不一致，则已经出现矛盾 i.e.这是贪心下的全局最优解）. 同理若不匹配且遇到的是&rsquo;x&rsquo;，则需回退至第5个.</p>
<p>从而我们定义dp数组的含义为<strong>假定指针i遇到&rsquo;x&rsquo;，则寻找以&rsquo;x&rsquo;结尾的最长公共前后缀&rsquo;x&rsquo;所在前缀的末位索引</strong>. 最长公共前后缀，即满足<code>s,x,....,y,s(x≠y)</code>的字符串<code>s</code>，注意到每次模式串多一个字符，最长公共前后缀最多增加1，但可能会减少很多回到之前的模式串中(头部没有改变)，从而化归成了一个子问题. 最后一个问题在于，如何进行<strong>状态更新</strong>.</p>
<p>显然在模式串的不同位置遇到不同字母的响应是不一样的，因此dp可能是二维的，不妨设<code>nxt[Index][States]=Position</code>
但不妨再考虑能否状态压缩，即我们不考虑遇到不同字母的情况，或者每次都多进行一次匹配.</p>
<p>考虑下面的一个流程，对t使用双指针，其中i扫描字符串，j扫描前缀，假定i和j+1失配(j+1即状态压缩的好处)，则j此时考虑回退到nxt[j]，即和j有相同后缀的地方，若相同，则可继续同步移动i,j；若再次失配，则j只能不断回退并判断是否相同直至为0. 再考虑初始化，由于最长公共前后缀不允许有交集，从而需要从i=2,j=0的位置开始(<code>nxt[0]=nxt[1]=0</code>).</p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>KMP</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">int nxt[N]={0};
void init(string s){
	int n=s.length();
	for(int i=2,j=0;i&lt;n;i&#43;&#43;){
		//不满足则不断回退，由于j可能倒退，j&#43;1≤i恒成立
		while(j &amp;&amp; s[i]!=s[j&#43;1])	j=nxt[j]; 
		//此时可能满足也可能已经回到0，满足则同步移动
		if(s[i]==s[j&#43;1])	j&#43;&#43;;	
		nxt[i]=j;
	}
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<p>再进行模式匹配，注意匹配时i必须初始化为1（j必须从0开始，而j+1要预留一个位置）
下面对i=1的合理性说明：若s[1]≠t[1]，则s[0]无论是否与t[0]匹配都需被舍弃；若s[1]=t[1],其中会出问题的只有s[0]≠t[0]，如用<code>caaa</code>匹配<code>daaaa</code>，这类情况需进行特判，即先找到第一个i使得<code>s[i-1]=t[0]</code>再开始用算法

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>KMP</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">vector&lt;int&gt; find(string s, string t){
	vector&lt;int&gt; begins;
	for(int i=1,j=0;i&lt;s.length();i&#43;&#43;){
		while(s[i]!=s[j&#43;1])	j=nxt[j];
		if(s[i]==t[j&#43;1])	j&#43;&#43;;
		//已经查找到末尾
		if(j==t.length()){
			begins.push_back(j-t.length());
			j = nxt[--j];
		}	
	}
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</p>
<p>我们发现，这个过程与<code>t</code>和<code>s</code>的KMP匹配很相似（i扫描模式串，j扫描前缀），仿佛是<code>t</code>和<code>t</code>的KMP匹配.</p>
<h4 id="sample-problem">Sample Problem:</h4>
<p><strong>Problem</strong> 给定字符串s和t，问：最多能从s中分割出多少个t?
<strong>Analysis</strong> 利用贪心. 从左到右用KMP匹配遇到一个计数一次且j直接回退到0.</p>
<h4 id="32-扩展kmp算法z函数">3.2 扩展KMP算法(Z函数)</h4>
<p>算法和KMP类似，但显然更易. Manacher算法也借鉴了<strong>利用已经求解的部分加速计算</strong>这一核心思想.</p>
<p><strong>Z函数</strong>$Z(i)$定义为从位置i开始的字符串和从0开始的</p>
<p>假定已经计算出$z[i-1]=k$，现在来看$z[i]$，显然$[i-1,i-1+k]$这一部分是和前缀完全相同的，现在$z[i]$理论上和$z[1]$相等，故可直接照抄，即$z[i]=z[1]$. 这个范围$[i-1,i-1+k]$即为<strong>Z-Box</strong>. 对于Z-Box内部的位置，可利用之加速运算，故有以下情况：</p>
<ul>
<li>若i&lt;r，即i位于z-box中，若$z[i-l]$的值使得$i+z[i-l]$超出z-box的右边界，则不能直接取得，必须从右边界开始暴力枚举直至与前缀不同；若还在右边界内，则直接赋值</li>
<li>若i&gt;r，则继续暴力枚举

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>Z Function</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">void get_z(string s){
	int n = s.size(); int z[n]={0};
	z[0]=n;
	for(int i=1, l,r=0; i&lt;n;i&#43;&#43;){
		if(i&lt;=r)	z[i]=min(z[i-l&#43;1],r-i&#43;1);
		while(s[z[i]]==s[i&#43;z[i]])	z[i]&#43;&#43;; //向右探索边界
		if(i&#43;z[i]-1&gt;r)	l=i,r=i&#43;z[i]-1; //更新边界
	}
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
</li>
</ul>
<h4 id="33-manacher算法">3.3 Manacher算法</h4>
<p>Manacher算法用于求解<strong>字符串的最长回文子串</strong>，若暴力枚举则需$O(n^3)$，以中心向两边暴力扩展(需对奇偶分类讨论)则为$O(n^2)$，若扩展的同时使用二分，则为$O(n\log n)$. 使用Manacher算法则可优化至线性.</p>
<p>为便于处理，在字符串中插入非法字符使得所有字符串被化为奇字符串. 定义<strong>回文半径为包含回文中心的向两侧走的最长距离</strong>，如<code>abad</code>中<code>r(b)=2</code>. 维护回文半径这一数组即可.</p>
<p>与扩展KMP类似，回文串也可利用之前的回文串.</p>
<ul>
<li>当i在右边界外时，对i暴力拓展</li>
<li>当i在右边界内时，考察<strong>i关于回文中心的对称点j</strong>，若j的回文范围内没有超过左边界，则i与之对称，也没有超过右边界，从而<strong>r[i]=r[j]</strong></li>
<li>否则需在右边界开始暴力拓展</li>
</ul>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>Manacher</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">void get_r(string s){	//假定s已经处理过
	s[0]=1;
	for(int i=1, l,r=1;i&lt;s.size();i&#43;&#43;){
		if(i&lt;=r)	r[i]=min(r[r-i&#43;l],r-i&#43;1);
		while(s[i-r[i]]==s[i&#43;r[i]])	r[i]&#43;&#43;;
		if(i&#43;r[i]-1&gt;r)	l=i-r[i]&#43;1, r=i&#43;r[i]-1;
	}
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<h2 id="4-ac自动机多模态匹配">4. AC自动机：多模态匹配</h2>
<p>在<strong>多模态匹配</strong>问题中，i.e. KMP中待匹配的字符串有多个时，此时可借用trie的结构. 该类问题在屏蔽敏感词等领域有广泛应用，其中在此问题中不仅需要在找到敏感词的同时减少回退次数，还要找出所有敏感词，如<code>she</code>中可能包含<code>she</code>和<code>he</code>两个敏感词.</p>
<p>首先建立字典树并在patterns结束节点处标记该敏感词长度，和KMP相同，需要考虑当失配时fail指针的指向位置，从而避免从0开始. 与KMP类似，我们需要对给定的模式串每个经过的节点设置fail指针，其中root表示模式串的起点，显然root的fail指针必须指向root(即全部失配时必须从头开始匹配)，下面从具体例子看：</p>
<p>对<code>s=&quot;abcd&quot;</code>其中<code>bcd</code>和<code>cd</code>是模式串，则从root深入b,c,d，到达d尾节点时，由于标记有<code>2,3</code>，回退2、3次得到子串<code>cd</code>和<code>bcd</code>. 对<code>s=&quot;abcdef&quot;</code>，发现在以<code>a</code>开头，以<code>e</code>结尾失配时，我们问：是否以<code>b</code>开头的有可能不失配？从而我们尝试回退，此时已匹配的字符串长度至少减1，因此看<strong>e的父节点d的fail指向的下面是否能通向e</strong>，即考查<code>d</code>后面是否能连接<code>e</code>. 直至回退到顶点.</p>
<p>不难发现，fail指针的建立和字符串长度有关(至少fail对应的深度是单调不增的)，因此需采取层序遍历，将所有节点(无论是否是尾结点，因为均有可能失配)建立fail指针.</p>
<p>在实际编码时，若子结点存在，则子结点的fail指向父结点fail指向的同向子结点，即<strong>回跳边</strong>；若不存在该子结点，则该子结点的fail指向当前结点fail指向的同向子结点，即<strong>转移边</strong>. 可以这样理解：AC自动机每次找到的一定是<strong>最长符合条件的后缀</strong>，因为再往下找必然失配(与&quot;最长&quot;矛盾)，此时则需考虑最长后缀中去掉前缀是否也是符合题意的，即利用回跳边(fail)指针，缩减长度. <strong>实际上只有回跳边已经足够，但还可以再优化，即引入转移边将树变为图</strong>，转移边一定是转移最短路，含义即当前走到叶子节点(字符串全部匹配但不可能得到更长的公共前缀，必须利用回退去掉尽可能多的前缀)，例如模式串为<code>a,aa,aaa</code>但匹配串为<code>aaaaa</code>，当到达第四个a时，尽管全部匹配，但由于超过该情况下模式串最长长度(3个a)，必须执行回退.</p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>AC</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">int t[N][26], cnt[N], idx=0;
int nxt[N]={0}; //一个结点只有一个fail指针，默认指向根节点
void insert(string s){	//建树
	int p=0;
	for(int i=0;i&lt;s.length();i&#43;&#43;){
		int j = s[i]-&#39;a&#39;;
		if(!t[p][j])	t[p][j]=&#43;&#43;idx;
		p=t[p][j];
	}
	cnt[p]&#43;&#43;;
}

void build(){
	queue&lt;int&gt; q;
	for(int i=0;i&lt;26;i&#43;&#43;)
		if(t[0][i])	q.push(t[0][i]);	//初始化
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;26;i&#43;&#43;){
			int v = t[u][i];
			if(v)	nxt[v]=t[nxt[u]][i],q.push(v);
			else	t[u][i]=t[nxt[u]][i];
		}
	}
}

int query(string s){
	int ans=0;
	//k扫描字符串，p为当前指针，j从p开始扫描模式串直至回到根节点(即不断去除前缀检测是否符合)
	//每次都可用j扫描的合理性：这种算法决定前缀一定不漏解(在不断变长时已经计数)，只有后缀会漏，
	//例如`abc`，当已知最长后缀为`ab`时，需检测`b`是否符合；为`abc`时，不可能再回到`ab`的情况(只删前缀)
	for(int k=0,p=0;s[k];k&#43;&#43;){
		p=t[i][s[k]-&#39;a&#39;];
		//若重复的只统计一次；若需多次统计，则去掉~cnt[j]和cnt[j]=-1
		for(int j=i;j&amp;&amp;~cnt[j];j=nxt[j])	
			ans&#43;=cnt[j],cnt[j]=-1;
	}
	return ans;
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<h4 id="sample-problem-玄武密码">Sample Problem: 玄武密码</h4>
<p><strong>Problem</strong> 给定一些模式串<code>t[n]</code>和一个字符串<code>s</code>(只含WSNE四个字母)，求<code>s</code>中出现各个模式串<code>t[n]</code>中最长前缀的长度.
<strong>Sample</strong></p>
<pre tabindex="0"><code>Input: 7 3 SNNSSNS NNSS NNN WSEE
Output: 4 2 0
</code></pre><p><strong>Analysis</strong> 在AC自动机跑的时候，每个节点都可能导致最长前缀进行更新，而fail指针会去掉一些前缀，可能导致信息损失. 也即我们想要的答案<strong>在AC自动机运行过程中</strong>，故而需要进行标记. 其中注意到核心问题在于需要判断当前位置对应的最长模式串的位置对应的是哪一个，由于AC自动机的底层结构是trie，自然地，<strong>可以把模式串当作字符串放进去</strong>，这样一定能匹配成功且达到最大长度. 而且由于AC自动机是模式串的trie结构，即每一个模式串进去的路径一定唯一(fail指针不改变路径，只是跳过重复路径)，从而只需<strong>标记该节点是否访问</strong>. <strong>每个模式串扔进去遇到的访问节点数即所求</strong>.</p>
<h2 id="5-最小表示法">5. 最小表示法</h2>
<p>长度为n的字符串，若存在一个置换映射矩阵使得$X=AY$，则称X和Y是<strong>本质相同的</strong>.(不局限于字符串) 以$C^k,k=0,..,n-1$为置换群(n阶循环矩阵C)的字符串，称<strong>循环同构</strong>，其中字典序最小的一个称<strong>最小表示</strong>. 现希望在线性时间内找到该表示.</p>
<p>对环类问题，一般通过复制一遍达到化环为链(<strong>也可mod n表达相同意思</strong>)，再通过双指针法确定对应位置.</p>
<p>定义<strong>i,j</strong>是起始位置指针，<strong>k</strong>是匹配长度，初始化为0,1,0，下面来看：</p>
<ul>
<li>当s[i+k]==s[j+k]时，匹配成功，k++</li>
<li>当s[i+k]&gt;s[j+k]时，匹配失败，此时注意到j不可能是最优解，因为从i开始的一定比j开始的更优；再看从i+1开始的，由于能匹配到j+k&gt;j+1，一定有i+1=j+1，而又因为子串[i+1,i+k-1],[j+1,j+k-1]完全相同，从而从j+1开始的一定更优，从而i更新为i+k+1.</li>
<li>当s[i+k]&lt;s[j+k],j=j+k+1.</li>
<li>若i，j移动后重合，则i++或j++让i,j错开</li>
</ul>
<p>可以看到，该算法无论如何都不会排除掉最优解，而i,j整体前进，算法收敛，故而当i,j有一方不小于n时算法停止. 而停止时不小于n的那个一定是因为位置被更新，即字典序大的那个，故要返回小于n的那个，即二者的较小值.</p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>minumum_expression.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">int minimum_expression(string s){
	int n = s.size();
	int i=0, j=1, k=0;
	while(i&lt;n&amp;&amp;j&lt;n){
		if(s[(i&#43;k)%n]==s[(j&#43;k)%n])	k&#43;&#43;;
		else if(s[(i&#43;k)%n]&gt;s[(j&#43;k)%n]) i=i&#43;k&#43;1;
		else j = j&#43;k&#43;1;
		if(i==j)	i&#43;&#43;;
	}
	return min(i,j);
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<p><strong>例题</strong> 给定字符串s和整数k，可以将s的前k个字母中选择一个移动到s的末尾，该操作不限制次数，求可以得到的最小字典序字符串.</p>
<p>  <strong>分析</strong> 若k=1，则为循环置换，直接套用最小表示法；若k&gt;1，则通过一次对换+(n-1)次循环置换，可以构造出任意序列，可用任意排序算法.</p>
<h2 id="6-哈希函数与哈希表hash">6. 哈希函数与哈希表(Hash)</h2>
<p>哈希表，键值对(key-value pair)通过构建一一映射$h:A→R$，存储时将key(key代表的是可以是字符串等各种数据类型)转换成value，查询时直接通过key找到其位置.</p>
<p><strong>常见哈希函数：（前4种为数字哈希，即R→R；后者为str→R）</strong></p>
<ul>
<li><strong>直接地址</strong>. 即<strong>桶排序</strong>的思想. $h(i)=i$</li>
<li><strong>取余</strong>.选择较大质数p，$h(i)=i%p$</li>
<li><strong>平方取中</strong>. 取中间的k位为哈希值(平方值长度根据奇偶讨论)，如1234的平方为1522756，则可取中间3位为哈希值，即227.</li>
<li><strong>乘法哈希</strong>. 将关键值乘以一个小常数(0&lt;A&lt;1)，并取小数部分的前k位(不能太多，浮点数不精确)，并乘以哈希表大小，取整为哈希.</li>
<li><strong>字符串哈希</strong>.如直接相加、多项式哈希与BKDR哈希等. 下面介绍多项式哈希.</li>
</ul>
<p><strong>多项式哈希</strong> 选取合适的$p,M s.t. (p,M)=1$，一般p取131或13331，M取大整数$2^64$并将哈希函数值定义为无符号整型(溢出相当自动取模)，从而定义$$h(s)=\sum_{i=0}^{n-1}s_ip^{n-i}$$</p>
<p>如abcde定义为$a×p^4+b×p^3+c×p^2+d×p^1+e$，要<strong>考虑子串存在性的问题</strong>，可采用字符串哈希快速计算，<strong>定义前缀和</strong>为对应哈希函数值，故有子串哈希值$h(s_i&hellip;s_{i+n})=h(s_i)-h(s_{i-1}×p^{n+1})$. 判断字符串是否相等，只需检测哈希值是否相同.</p>
<p><strong>哈希冲突</strong> 如存储一串数据时，定义哈希函数为$h(n)=n%7$，则1和8都会占用同个位置，即发生哈希冲突. 解决哈希冲突可以从<strong>根据数据特点改进哈希函数、更改存储结构、改进分配冲突元素的方法</strong>等方面入手，当哈希冲突非常严重，即发生<strong>密集度差异明显</strong>时需引起注意.</p>
<ul>
<li>线性探测法. 假定h(n)被占用，则考察$h(n)+1$，直至有空位置.</li>
<li>平方探测法. 考察$h(n)+i^2$.</li>
<li>链地址法(Chaining)/拉链法. 即存储结构中的第二种.</li>
<li>双重哈希/再哈希法. 使用第二个哈希函数</li>
</ul>
<p><strong>存储结构：线性表</strong></p>
<ul>
<li><strong>顺序型.</strong> 若有哈希冲突造成一堆数据堆叠，在删除时需要整体移动，插入时复杂度也较高. 当数据元素过满时，需新建哈希表.</li>
<li><strong>顺序表头+链表.</strong> 表头（哈希桶）进行分类，对冲突元素<strong>头插</strong>，仍存在哈希冲突问题，只是减少冲突分配时的时间花费，在查询时没有明显优势.</li>
</ul>
<h2 id="7-异或与线性基">7. 异或与线性基</h2>
<p>异或运算，不涉及进位的按位运算. 满足交换与结合律，即(N,^)构成交换群，其中0为单位元</p>
<ul>
<li>a^a=0, 0^a=a</li>
</ul>
<p><strong>例1(异或的基本性质)</strong> 仅使用异或实现：</p>
<ol>
<li>交换两个整数a,b</li>
<li>一个数组中有一个数a出现奇数次，其余的偶数次，求a.</li>
<li>在(2)的条件下，a,b出现奇数次，分别求a,b.</li>
</ol>
<p>   <strong>Sol.</strong> (1)设$a=x,b=y$,则<code>a=a^b;b=a^b;a=a^b</code>，其中第一次a=x^y,b=y,第二次b=x^y^y=x;第三次a=x^y^x=y，即<strong>交替三次异或</strong>. (2)将所有数异或，偶数次相消；(3)同理将所有数异或，但得到a^b. 而由于a,b不等，a^b非零，一定至少有一位是1，<strong>该位表明a和b在这位上不同，从而将a,b分成两类</strong> 假设找到这个1在第x位，则将所有满足第x位为0的异或(为1也可)，得到a.从而b=a^b^a.</p>
<p>对异或运算，也具有<strong>前缀和</strong>的定义. 这是由于异或则抵消前面的部分，故定义前缀和$S_n=a_0\oplus&hellip;\oplus a_n$，从而区间异或和为$a_m\oplus &hellip;\oplus a_n = S_n\oplus S_{m-1}$</p>
<p><strong>例2(区间异或和与线段树)</strong></p>
<ol>
<li>
<p>(线段树维护)</p>
</li>
<li></li>
</ol>
<p><strong>例3(异或和的和)</strong></p>
<ol>
<li>(2023C++/A) 异或和之和. 给定n个数，求满足$1\leq L\leq R\leq n$的所有区间$[L,R]$异或之和.</li>
</ol>
<p>   <strong>Sol.</strong></p>
<p>对<strong>第k大异或</strong>问题，需引入异或线性基的概念. 类比线性空间，但<strong>只对加法进行定义为异或</strong>(没有数乘运算，或将数乘定义为恒等变换)，对每一个数，可按二进制认为是线性空间$Z^d$中的一个向量，从而将一个数组看成向量组，其中0为加法零元. 由线性空间的性质，可知存在个数相等的极大线性无关组(基)，使得其<strong>张成的线性空间涵盖整个数组且去掉无关组任意一个向量，该向量不在余下向量张成的空间中</strong>. 将这一无关组称<strong>线性基</strong>，容易知道：</p>
<ol>
<li>由极大无关组的相互表出，可定义向量组d[N]使得该向量组的最高位是第N位(d[N]的值).类比阶梯型矩阵，可知该向量组也是一个线性基.</li>
<li>不存在任何子集使得线性基相互异或(不能自异或)得0.(相当于无关组相加为零，表相关)</li>
</ol>
<p>运用<strong>基扩张定理</strong>，对一个向量a，若想将其添加至线性基中(不能直接加入，因为不一定构成阶梯型)，需先判断最高位x，再看d[x]是否已有基；<strong>若有，则x^=d[x]</strong>(x<strong>一定变小</strong>，保证收敛性)，直至d[x]为空或x=0(x=0说明线性相关).</p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>insert.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">ll d[N];
bool insert(ll x){
	for(int i=62;~i;i--){
		if(x&gt;&gt;i &amp;&amp; d[i])	x^=d[i];
		else {d[i]=x; return true;}
	}
	return false;//表示线性相关，需特判
}</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<p>在第k大异或问题中，若将k进行二进制表示，如$[5]_{10}=[101]_2$，则p[0]$\oplus$p[2]为所求，<strong>其中p[]是d[]的倒置，即p是右下三角阶梯矩阵</strong>. 理由是构成双射，对从小到大的阶梯型矩阵，p[0]$\oplus$p[2]和p[0]$\oplus$p[1]$\oplus$p[2]两种情形，即将<strong>某一位1变成0，则对应位数少进行异或，一定会让这个数变小</strong>，故<strong>存在序关系</strong>. 存在一个从二进制自然数到十进制自然数的双射，故成立.</p>
<p><strong>其中注意特判0的存在性，即是否这些数线性相关</strong>. 否则在二进制分解时，d[0]一定非零，从而返回的是res$\oplus$d[0]. 如ask_kth(1)(第1小的异或和)，返回的是d[0]而不是零(<strong>p[]的大小小于数组大小，说明不满秩</strong>)，从而询问到的是第2小.</p>

  
    
  
  
    
  
  
  


<figure class="highlight cpp language-cpp">
  <figcaption>
    
      <span>insert.cpp</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>
        </td>
        <td class="code">
          <pre class="code-highlight language-cpp cpp"><code class="cpp">ll d[N], p[N]; int cnt=0;
//处理d[x]，有放向量的才需统计
for(int i=0;i&lt;=62;i&#43;&#43;)
	if(p[N])	d[cnt&#43;&#43;]=p[i];

ll ask_kth(ll x){
	ll res = 0;
	for(int i=0;i&lt;=62;i&#43;&#43;)	//二进制分解
		if(x&gt;&gt;i)	res^=p[i];
	return res;
}

//询问：对0特判
if(p.size==array.size)	ask_kth(k);
else ask_kth(k-1);</code></pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<p><strong>例4(异或最值)</strong></p>
<ol>
<li>求一组数的最大、最小异或.</li>
</ol>
<p>   <strong>Sol.</strong> 可用0-1trie，但本质是线性基. 将所有数做插入，并将其全部异或可得最大值；对最小值，若满秩则取d[0]，否则为0.</p>
<ol start="2">
<li>给出n对数字(num,val)，选择若干组使得num的异或和非零时val加和的最大值.</li>
</ol>
<p>   <strong>Sol.</strong> 异或和非零即选取找到一个基，利用贪心，将val降序，依次插入.(正确性依据：<strong>同一个线性空间的基的大小相同</strong>)</p>
              


            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://Supradax.github.io/tags/algorithm/">Algorithm</a>

  <a class="tag tag--primary tag--small" href="https://Supradax.github.io/tags/graph/">Graph</a>

                  </div>
                
              
            
            
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://Supradax.github.io/2023/04/algorithmnetwork-flow-ek-and-dinic/" data-tooltip="[Algorithm]Network Flow: EK and Dinic" aria-label="NEXT: [Algorithm]Network Flow: EK and Dinic">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://Supradax.github.io/2023/03/calculuscurvilinearsurface-and-multiple-integral-ep.1/" data-tooltip="[Calculus]Curvilinear,Surface and Multiple Integral: ep.1" aria-label="PREVIOUS: [Calculus]Curvilinear,Surface and Multiple Integral: ep.1">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://Supradax.github.io/2023/04/data-sturcturetrie-string-algo-and-xor/" title="Share on Facebook" aria-label="Share on Facebook">
          <i class="fab fa-facebook-square" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://Supradax.github.io/2023/04/data-sturcturetrie-string-algo-and-xor/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/sharing/share-offsite/?url=https://Supradax.github.io/2023/04/data-sturcturetrie-string-algo-and-xor/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
    <li class="post-action">
      <a class="post-action-btn btn btn--default" href="#disqus_thread" aria-label="Leave a comment">
        <i class="far fa-comment"></i>
      </a>
    </li>
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


            
  
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
    <script type="text/javascript">
      var disqus_config = function() {
        this.page.url = 'https:\/\/Supradax.github.io\/2023\/04\/data-sturcturetrie-string-algo-and-xor\/';
        
          this.page.identifier = '\/2023\/04\/data-sturcturetrie-string-algo-and-xor\/'
        
      };
      (function() {
        
        
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
          document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
          return;
        }
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        var disqus_shortname = 'hugo-tranquilpeak-theme';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
  


          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2023 Supradax. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://Supradax.github.io/2023/04/algorithmnetwork-flow-ek-and-dinic/" data-tooltip="[Algorithm]Network Flow: EK and Dinic" aria-label="NEXT: [Algorithm]Network Flow: EK and Dinic">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://Supradax.github.io/2023/03/calculuscurvilinearsurface-and-multiple-integral-ep.1/" data-tooltip="[Calculus]Curvilinear,Surface and Multiple Integral: ep.1" aria-label="PREVIOUS: [Calculus]Curvilinear,Surface and Multiple Integral: ep.1">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://Supradax.github.io/2023/04/data-sturcturetrie-string-algo-and-xor/" title="Share on Facebook" aria-label="Share on Facebook">
          <i class="fab fa-facebook-square" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://Supradax.github.io/2023/04/data-sturcturetrie-string-algo-and-xor/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/sharing/share-offsite/?url=https://Supradax.github.io/2023/04/data-sturcturetrie-string-algo-and-xor/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
    <li class="post-action">
      <a class="post-action-btn btn btn--default" href="#disqus_thread" aria-label="Leave a comment">
        <i class="far fa-comment"></i>
      </a>
    </li>
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


      </div>
      
<div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-times"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2FSupradax.github.io%2F2023%2F04%2Fdata-sturcturetrie-string-algo-and-xor%2F" aria-label="Share on Facebook">
          <i class="fab fa-facebook-square" aria-hidden="true"></i><span>Share on Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2FSupradax.github.io%2F2023%2F04%2Fdata-sturcturetrie-string-algo-and-xor%2F" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2FSupradax.github.io%2F2023%2F04%2Fdata-sturcturetrie-string-algo-and-xor%2F" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i><span>Share on Linkedin</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>


    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-times"></i>
    </div>
    
      <img id="about-card-picture" src="https://www.gravatar.com/avatar/8e403bced8f86fcc7a8e6a31b21c7302?s=110" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Supradax</h4>
    
      <div id="about-card-bio">An <strong>Onward</strong> Learner</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        <strong>HITsz</strong>er
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker-alt"></i>
        <br/>
        Shenzhen,China
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://Supradax.github.io/img/cover.png');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js" integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script src="https://Supradax.github.io/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js"></script>


  
    <script async crossorigin="anonymous" defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js"></script>
  


<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>




    
  </body>
</html>

